<!doctype html>
<meta charset=utf-8>
<body id=b>
<canvas id=a width=1000 height=1000>
<script>
d = document;
g = a.getContext('webgl');

/*
=========================
 WebGL Shader Playground
=========================

JS1k entry by The Codegolf Team (xem, LiterallyLara, nderscore, Subzey)
Inspired by htp://www.shadertoy.com
Based on http://xem.github.com/MiniShadertoy
Full story on http://xem.github.io/articles/#webgl_quest
Cheers to aemkei, p01 and sqaxomonophonen who also contributed to the original app.

~~~

This demo provides a fully functional, mobile-friendly WebGL shader playground (canvas + textarea),
with a built-in demo (made by LiterallyLara), mouse support, shareable URLs, and compatibility with Shadertoy:
Demos created in this playground also work on Shadertoy,
and Shadertoy's demos that only feature a shader (i.e. no channels or other assets) will also work here.
(for example: https://www.shadertoy.com/view/Ms2SD1)
The canvas can also be set to fullscreen size by double-clicking it.

~~~

The shader inputs have the same name as the ones provided by Shadertoy:
- uniform vec3  iResolution; // viewport resolution = vec2(1000.0, 1000.0)
- uniform float iGlobalTime; // playback time (in seconds)
- uniform float iTimeDelta;  // render time since last frame (in seconds)
- uniform int   iFrame;      // playback frame
- uniform vec4  iMouse;      // xy: mouse coordinates in px, between 0 and 1000 (if left button is down)
                             // zw: click coordinates between 0 and 1000
- uniform vec4  iDate;       // current timestamp in seconds

Your shader must be placed in the following function:

void mainImage(out vec4 color,in vec2 coord){
  // code
}

~~~

The following commented code is very complex due to the extreme code-golfing required to make it fit in 1kb.
For more readability, you can first read our first (ungolfed) version here: https://github.com/xem/MiniShadertoy/blob/gh-pages/ungolfed.js

~~~

JS1K's shim gives the following vars for free:
- a: canvas element
- b: body
- d: document
- g: webgl context for the canvas.

*/

// Add a textarea called "c" in the body.
// Its content is either the hash of the top window (minus the leading "#") decoded from base64 if any, or the built-in demo.
// y (mouse down flag) and z (fullscren flag) are initialized to 1.
b.innerHTML+=`<textarea id=c>` +
(
  atob(
    top.location.hash.slice(
      y = z = 1
    )
  )
  ||
  `// WebGL playground!\nvoid mainImage(out vec4 color,vec2 coord){\n vec4 p=vec4((coord/iResolution-.5)*2.,0,1);\n color=p+sin(atan(p.y,p.x)*9.)*sin(p*iGlobalTime/2.+9./dot(p,p)+iGlobalTime*5.);\n}`
);

// Redefine "g" as the canvas' WebGL context, because it was lost when we added the textarea.
// Parenthesis can be omitted around teplate literals (more details: http://xem.github.io/articles/#webspeech)
// Hash all the WebGL context methods and constants we'll need in this demo, to access them with only 2 letters:
// createProgram => cP
// shaderSource => sS
// createShader => cS
// compileShader => ce
// attachShader => aS
// linkProgram => lo
// useProgram => ug
// bindBuffer => bf
// createBuffer => cB
// enableVertexAttribArray => eV
// vertexAttribPointer => vA
// bufferData => bD
// getUniformLocation => gf
// drawArrays => dr
// FRAGMENT_SHADER => FN (value: 35632)
// ELEMENT_ARRAY_BUFFER_BINDING => ET (value: 34965)
for(i in g = a.getContext`webgl`){
  g[i[0] + i[6]] = g[i]
}

// Put "g" in the current scope to use any method / constant without having to write "g."
with(g){

  // Define the oninput function, called everytime the textarea is edited...
  // NB: all the demo's function have a parameter called e to repeat "=e=>" and optimize RegPack compression
  (
    oninput = e => {

      // Update the main window's hash with the shader code in base64
      top.location.hash = btoa(c.value),

      // h = g.FRAGMENT_SHADER = 35632
      h=FN,

      // Call g.vertexAttribPointer with the following params:
      // vertex_index = 0, components_per_vertex_attribute = 2, vertex_attributes_type = g.BYTE = 5120, normalized = 0, stride = 1, offset = 0.
      vA(

        // Call g.createProgram to create the program p and return 0 as the 1st param of vA
        p = cP(

          // define the function i that takes a source string e...
          i = e => {

            // sets the shader's source (g.shaderSource)...
            sS(

              // with a new shader s (g.createShader), and increases h by 1 at the same time...
              s = cS(h++),

              // and e.
              e
            )

            // (The following "|" and "!" are used to return 1 when i is called)
            |

            // compiles the shader (g.compileShader)...
            ce(s)

            |

            // and attaches the shader to p (g.attachShader).
            !aS(p, s)
          }
        ),

        // 2nd param of vA
        2,

        // 3rd param of vA
        5120,

        // Fill bD (g.bufferData), and return 0 as the 4th param of vA
        bD(

          // Initialize n (the 1st param of bD) to g.ARRAY_BUFFER = 34962 = g.ELEMENT_ARRAY_BUFFER_BINDING - 3.
          // we can't use g.ARRAY_BUFFER = g.AB as it's overwritten by another constant during hashing)
          n = ET - 3,

          // Set the coordinates of a big triangle surrounding the canvas (x1=1, y1=x2=B, y2=x3=1, y3=1) as the 2nd param of bD.
          // The coordinates overlap because the "stride" param of vA is set to 1.
          // Int8Array.of(...) is the same as new Int8Array(...), just shorter. 
          Int8Array.of(

            // x1 = i(...) = 1.
            // We call i() a first time to define the fragment shader with the content of the textarea and the real main function (at this moment, g.FN = g.FRAGMENT_SHADER = 36532)
            i(`precision mediump float;uniform float iGlobalTime,iFrame,iDate,iTimeDelta;uniform vec2 iResolution;uniform vec4 iMouse;`
            +c.value
            +`void main(){mainImage(gl_FragColor,gl_FragCoord.xy);gl_FragColor.w=1.;}`),

            // y1 = x2 = n = 34962
            n,

            // y2 = x3 = !eV(0) = !g.enableVertexAttribArray(0) = 1
            !eV(

              // Use bf (g.bindBuffer) to bind the buffer created on-the-fly with cB and return 0
              bf(

                // g.ARRAY_BUFFER
                n,

                // g.createBuffer
                cB(

                  // Initialise m (iMouse). x is set to 0 as well as o (iGlobaltime), j (iFrame) and d (iTimeDelta)
                  m = [o = j = d = 0]
                )
              )
            ),

            // y3 = A(Position=p=P;t=T;}) = 1. We call A() a second time to create the vertex shader (at this moment, n = 35633 = g.VERTEX_SHADER)
            i`attribute vec4 p;void main(){gl_Position=p;}`
          ),

          // 3rd param of bD: g.STATIC_DRAW = 35044 = 34962 + 82
          // We can't use g.S_ as it's overwritten by another constant during hashing
          n + 82
        ),

        // Link the program p (g.linkProgram), return 1 as 5th param of vA
        !lo(p),

        // Use the program P (g.useProgram), return 0 as 6th param of vA
        ug(p)
      ),
      f = new Date / 1e3
    }
  )

  // Call oninput on load
  (

    // The onmousemove function updates m[0] and m[1] (i.e. iMouse.xy) when the canvas is hovered and y=0 (when the left click is pressed)
    // It's placed here in the oninput() to save space (no ";" at the end)
    // The ES6 deconstruction ([a,b]=[c,d]) looks longer but it packs better.
    // Coordinates are adjusted to be between 0 and 1000 (the canvas size)
    a.onmousemove = e => {
      y
      ||
      (
        [m[0], m[1]] = [e.pageX * z * 1e3 / innerWidth, e.pageY * 1e3 / innerHeight]
      )
  ),

  // Define the loop function "l"
  (
    l = e => {

      // At each frame:
      // Update iTimeDelta (time since last frame),
      uniform1f(gf(p, `iTimeDelta`), d = new Date / 1e3 - f),

      // iDate,
      uniform1f(gf(p, `iDate`), f = new Date / 1e3),

      // iGlobaltime (time since last input or reload),
      uniform1f(gf(p, `iGlobalTime`), o += d),

      // iMouse (mouse coords and click coords between 0 and 1000),
      uniform4f(gf(p, `iMouse`), m[0], m[1], m[2], m[3]),

      // iResolution (always 1000x1000),
      uniform2f(gf(p, `iResolution`), 1e3, 1e3),

      // and iFrame (incremented at each frame).
      // uniform1f returns 0, so it replaces the 0 in:
      // g.drawArray(mode=g.TRIANGLE_FAN=6, first=0, count=3)
      dr(
        6,
        uniform1f(gf(p, `iFrame`), j++),
        3
      ),

      // Recursive call synced with the screen refresh rate
      requestAnimationFrame(l)
    }
  )

  // Call l onload to start the loop
  (

    // The onclick function updates m.zw (m[2] and m[3]) when the canvas is clicked
    // It's placed here to save space.
    a.onclick = e => {
      [m[2], m[3]] = [e.pageX * z * 1e3 / innerWidth, e.pageY * 1e3 / innerHeight]
    }
  )
}

// The ondblclick function updates the style of the canvas (a) and the textarea (c) when the canvas is double-clicked
// It is also called on load to set their style and the style of the body (b) when the demo starts
(
  a.ondblclick = e => {

    // Define the CSS for a and c
    a.style = c.style = (

      // Define the CSS for b (also used by a and c)
      b.style = `height:100vh;margin:0;box-sizing:border-box;width:`
    )

    // Specify the width for a and c (half-screen or fullscreen, depending on the value of z
    // z toggles between 1 and 2 at each double-click
    + 100 / (z ^= 3)

    // Add "float:left" to a and c to leave no blank space in the page, and avoid scrollbars
    + `%;float:left`
  }
)
(

  // The onmousedown function toggles y when the mouse is down (then, y=0) or if the mouse is up (then, y=1).
  // It's placed here to save space.
  onmousedown = onmouseup = e => {
    y ^= 1
  }
)

// Minified: 1559b (see https://github.com/xem/MiniShadertoy/blob/gh-pages/js1k.min.html)
// RegPacked with the settings: 2/1/0: 1024b (see https://github.com/xem/MiniShadertoy/blob/gh-pages/js1k.min.pack.html)
// Cheers!

</script>