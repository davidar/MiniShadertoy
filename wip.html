<!doctype html>
<meta charset=utf-8>
<body id=b>
<script>
d = document;

/*
=========================
 WebGL Shader Playground
=========================

by The Codegolf Team
Inspired by www.shadertoy.com
Based on http://xem.github.com/MiniShadertoy
Full story on http://xem.github.io/articles/#webgl_quest

~~~

This demo provides a fully functional WebGL shader playground,
with a built-in demo, mouse support, shareable URLs, and a 2-way compatibility with Shadertoy.

Demos created in this playground also work on Shadertoy,
and Shadertoy's demos that only feature a shader (i.e. no channels or other assets) will also work here.
(for example: https://www.shadertoy.com/view/Ms2SD1)

The canvas can also be set to full size by double-clicking it.

~~~

The shader inputs are the same as the ones provided by Shadertoy:

uniform vec3  iResolution; // viewport resolution = vec2(640.0, 360.0)
uniform float iGlobalTime; // playback time (in seconds)
uniform float iTimeDelta;  // render time since last frame (in seconds)
uniform int   iFrame;      // playback frame
uniform vec4  iMouse;      // mouse pixel coords. xy: current (if left button down), zw: click
uniform vec4  iDate;       // current timestamp in seconds

Your code is executed from the following function:

void mainImage(out vec4 fragColor,in vec2 fragCoord){
  // code
}

*/


// GUI: canvas
b.innerHTML+=`<canvas id=a width=600 height=400 style='border:1px solid#000;width:47vw;height:95vh'>`;

// GUI: textarea with demo shader
b.innerHTML+=`<textarea id=c style=width:47vw;height:95vh>void mainImage(out vec4 fragColor,in vec2 fragCoord){
  vec4 p=vec4((fragCoord.xy/iResolution.xy-.5)*2.,0,1);
  fragColor=p+sin(atan(p.y,p.x)*9.)*sin(p*iGlobalTime/2.+9./dot(p,p)+iGlobalTime*5.);
}`;

// Canvas methods hashing:
// This loop creates tiny shortcuts for all the webgl context's methods/constants we need:
// createProgram => cP
// shaderSource => sS
// createShader => cS
// compileShader => ce
// attachShader => aS
// linkProgram => lo
// useProgram => ug
// bindBuffer => bf
// createBuffer => cB
// enableVertexAttribArray => eV
// vertexAttribPointer => vA
// bufferData => bD
// getUniformLocation => gf
// drawArrays => dr
// NO_ERROR => NO (value = 0)
// FRAGMENT_SHADER => FN (value: 35632)
// ELEMENT_ARRAY_BUFFER_BINDING => ET (value: 34965)
for(i in g=a.getContext("webgl")){
  g[i[0]+i[6]]=g[i];
}

// Fill the textarea if the hash is set, decoded from base64
if(l=location.hash){
  c.value=atob(l.slice(1));
}

// Mouse coordinates
iMouse=[0,0,0,0];

// Use the WebGL context's scope for all the following code
with(g){

  // Onload / oninput
  (oninput=function(){

    // Update hash with shader code in base64
    location.hash=btoa(c.value);

    // Define a new program
    // P=createProgram();
    P=cP();

    // Basic vertex shader
    // shaderSource(S=createShader(VERTEX_SHADER),"attribute vec2 P;void main(){gl_Position=vec4(P,0,1);}");
    sS(S=cS(35633),"attribute vec2 P;void main(){gl_Position=vec4(P,0,1);}");

    // Compile and attach it to the program
    // compileShader(S);
    ce(S);
    
    //attachShader(P,S);
    aS(P,S);

    // Main program
    // shaderSource(S=createShader(FRAGMENT_SHADER),'precision mediump float;uniform float iGlobalTime,iFrame,iDate,iTimeDelta;varying lowp vec4 fragCoord;uniform vec2 iResolution;uniform vec4 iMouse;' +c.value+'void main(){mainImage(gl_FragColor,gl_FragCoord.xy);gl_FragColor.w=1.;}');
    sS(S=cS(FN),'precision mediump float;uniform float iGlobalTime,iFrame,iDate,iTimeDelta;varying lowp vec4 fragCoord;uniform vec2 iResolution;uniform vec4 iMouse;'+c.value+'void main(){mainImage(gl_FragColor,gl_FragCoord.xy);gl_FragColor.w=1.;}');

    // Compile and attach it to the program
    // compileShader(S);
    ce(S);
    
    // attachShader(P,S);
    aS(P,S);

    // Link and start the program
    //linkProgram(P);
    lo(P);
    
    //useProgram(P);
    ug(P);

    // Define a big triangle the canvas, containing the viewport
    // bindBuffer(B=ARRAY_BUFFER, createBuffer());
    bf(B=34962,cB());
    
    // enableVertexAttribArray(0);
    eV(0);
    
    // vertexAttribPointer(0, 2, BYTE, 0, 0, 0);
    vA(0,2,5120,0,0,0);
    
    // bufferData(B,new Int8Array([-3, 1, 1, -3, 1, 1]), STATIC_DRAW);
    bD(B,new Int8Array([-3,1,1,-3,1,1]),35044);

    // Reset frame counter
    iFrame=0;

    // Reset playback time (in seconds)
    p=0;
    
    // Date (in seconds)
    D=new Date()/1e3
    
    // Time delta (in seconds)
    d=0;
  })();



  // Main loop
  (L=function(){

    // Time delta since last frame (in seconds)
    d=(new Date()/1e3-D);

    // Date (in seconds)
    D=new Date()/1e3;
    
    // uniform1f(getUniformLocation(P, "iTimeDelta"), d);
    uniform1f(gf(P,"iTimeDelta"),d);

    // Current playback time (in seconds)
    // uniform1f(getUniformLocation(P,"iGlobalTime"), p += d);
    uniform1f(gf(P,"iGlobalTime"),p+=d);
    
    // Current playback frame
    // uniform1f(getUniformLocation(P,"iFrame"),iFrame++);  
    uniform1f(gf(P,"iFrame"),iFrame++);  
    
    // Date
    // uniform1f(getUniformLocation(P,"iDate"), ~~D);
    uniform1f(gf(P,"iDate"),~~D);
    
    // Mouse coordinates
    // uniform4f(getUniformLocation(P,"iMouse"),iMouse[0],iMouse[1],iMouse[2],iMouse[3]);
    uniform4f(gf(P,"iMouse"),iMouse[0],iMouse[1],iMouse[2],iMouse[3]);
    
    // Viewport resolution
    // uniform2f(gf(P,"iResolution"), 640, 360);
    uniform2f(getUniformLocation(P,"iResolution"),640,360);
    
    // Draw
    // drawArrays(TRIANGLE_FAN,0,3);
    dr(6,0,3);
    
    // Next frame
    requestAnimationFrame(L);
  })();
}

// Mouse input:

// y: mouse down (0 / 1)
y=0;

// z: canvas size (1: half / 2: full screen)
z=1;

// Toggle y on mouse down / up
onmousedown=onmouseup=function(e){y^=1}

// Update iMouse on mouse move / click, according to z.
a.onmousemove=function(e){if(y)iMouse[0]=e.pageX*0.47*z,iMouse[1]=e.pageY}
a.onclick=function(e){iMouse[2]=e.pageX*0.47*z,iMouse[3]=e.pageY}

// On double click, toggle canvas size
a.ondblclick=function(e){z=3-z;a.style.width=c.style.width=z*47+'vw'}

/* End of golf */

</script>